/**
 * Клонирует шаблон и собирает все элементы с атрибутом data-name
 *
 * @param {string} templateId - ID элемента шаблона, существующего в документе (не безопасно!)
 * @returns {{container: Node, elements: unknown}} - Объект, содержащий контейнер и именованные элементы
 *
 * Подробнее: Эта функция использует HTML-шаблоны (<template>) для создания
 * переиспользуемых фрагментов DOM. Функция находит шаблон по ID, клонирует его
 * и собирает все вложенные элементы, у которых есть атрибут data-name,
 * в удобный объект для дальнейшего доступа к этим элементам.
 */
export function cloneTemplate(templateId) {
    // Находим шаблон в документе по его ID
    const template = document.getElementById(templateId);

    // Клонируем первый дочерний элемент шаблона вместе со всеми его потомками
    const clone = template.content.firstElementChild.cloneNode(true);

    // Находим все элементы с атрибутом data-name и создаем объект,
    // где ключами являются значения data-name, а значениями - сами элементы
    const elements = Array.from(clone.querySelectorAll('[data-name]')).reduce((acc, el) => {
        acc[el.dataset.name] = el;
        return acc;
    }, {});

    // Возвращаем объект с контейнером (клоном шаблона) и именованными элементами
    return {
        container: clone,
        elements: elements
    };
}

/**
 * Преобразует объект FormData в обычный JavaScript-объект (только одиночные значения)
 *
 * @param {FormData} formData - Объект FormData для преобразования
 * @returns {Object} - Обычный объект со значениями формы
 *
 * Подробнее: FormData — это специальный интерфейс для работы с данными форм,
 * но часто удобнее работать с обычными JavaScript-объектами. Эта функция
 * преобразует FormData в простой объект, где ключи соответствуют именам полей формы,
 * а значения - введенным данным. Обратите внимание, что эта функция обрабатывает
 * только одиночные значения и не поддерживает множественные значения для одного ключа
 * (как в случае с multiple select или checkbox).
 */
export function processFormData(formData) {
    // Преобразуем entries() в массив пар [ключ, значение] и создаем объект
    return Array.from(formData.entries()).reduce((result, [key, value]) => {
        result[key] = value;
        return result;
    }, {});
}

/**
 * Преобразует коллекцию в объект-индекс по уникальному полю
 *
 * @param {Array} arr - Исходная коллекция объектов
 * @param {string} field - Должно быть уникальным!
 * @param {(Object) => any} val - Функция преобразования значений
 * @returns {Object} - Объект, индексированный по указанному полю
 *
 * Подробнее: Эта функция полезна для создания справочников или поисковых индексов.
 * Она преобразует массив объектов в объект, где ключами выступают значения
 * указанного поля каждого объекта, а значениями — результат применения
 * функции-преобразователя к исходному объекту. Это позволяет быстро находить
 * объекты по их уникальному идентификатору с вычислительной сложностью O(1)
 * вместо O(n) при переборе массива.
 */
export const makeIndex = (arr, field, val) => arr.reduce((acc, cur) => ({
    ...acc,  // Копируем все уже накопленные значения
    [cur[field]]: val(cur)  // Добавляем новое поле с именем из cur[field] и значением из val(cur)
}), {});

/**
 * Возвращает массив номеров страниц, центрированный вокруг текущей страницы
 *
 * @param {number} currentPage - Текущая активная страница
 * @param {number} maxPage - Максимальный доступный номер страницы
 * @param {number} limit - Максимальное количество отображаемых страниц
 * @returns {number[]} Массив номеров страниц
 *
 * Подробнее: Эта функция создает массив номеров страниц для пагинации,
 * центрированный вокруг текущей страницы. Она особенно полезна для
 * пользовательских интерфейсов, где нужно отображать ограниченное количество
 * номеров страниц (например, "1 2 3 ... 10" вместо "1 2 3 4 5 6 7 8 9 10").
 *
 * Алгоритм гарантирует, что:
 * 1. Текущая страница находится примерно в центре отображаемого диапазона
 * 2. Количество отображаемых страниц не превышает указанный лимит
 * 3. Диапазон корректируется у краев (начало и конец списка страниц)
 */
export function getPages(currentPage, maxPage, limit) {
    // Проверяем, что входные данные являются корректными числами
    currentPage = Math.max(1, Math.min(maxPage, currentPage));  // currentPage должен быть от 1 до maxPage
    limit = Math.min(maxPage, limit);  // limit не должен превышать maxPage

    // Вычисляем диапазон страниц для отображения
    let start = Math.max(1, currentPage - Math.floor(limit / 2));  // Начинаем с currentPage минус половина лимита
    let end = start + limit - 1;  // Заканчиваем через limit страниц после start

    // Корректируем, если мы близко к концу
    if (end > maxPage) {
        end = maxPage;  // Не выходим за пределы максимальной страницы
        start = Math.max(1, end - limit + 1);  // Пересчитываем начало
    }

    // Создаем массив номеров страниц
    const pages = [];
    for (let i = start; i <= end; i++) {
        pages.push(i);
    }

    return pages;
}